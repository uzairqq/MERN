// extracted and slightly modified from object-inspect
import { functionName } from './functionName';
var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap
    ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor &&
    typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null ||
    Function.prototype;
var mapForEach = hasMap && Map.prototype.forEach || Function.prototype;
var hasSet = typeof Set === 'function' && Set.prototype || Function.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor &&
    hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor &&
    typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null ||
    Function.prototype;
var setForEach = hasSet && Set.prototype.forEach || Function.prototype;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
export function inspect(obj, seen) {
    if (seen === void 0) { seen = []; }
    if (typeof obj === 'undefined')
        return 'undefined';
    if (obj === null)
        return 'null';
    if (typeof obj === 'boolean')
        return obj ? 'true' : 'false';
    if (typeof obj === 'string')
        return inspectString(obj);
    if (typeof obj === 'number') {
        if (obj === 0)
            return Infinity / obj > 0 ? '0' : '-0';
        return String(obj);
    }
    if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }
    function internalInspect(value, from) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        return inspect(value, seen);
    }
    if (typeof obj === 'function') {
        var name_1 = functionName(obj);
        return '[Function' + (name_1 ? ': ' + name_1 : '') + ']';
    }
    if (isSymbol(obj)) {
        var symString = Symbol.prototype.toString.call(obj);
        return typeof obj === 'object' ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++)
            s += ' ' + attrs[i].name + '="' + quote(attrs[i].value) + '"';
        s += '>';
        if (obj.childNodes && obj.childNodes.length)
            s += '...';
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0)
            return '[]';
        var xs = Array(obj.length);
        for (var i = 0; i < obj.length; i++)
            xs[i] = has(obj, i) ? internalInspect(obj[i], obj) : '';
        return '[ ' + xs.join(', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = [];
        for (var key in obj) {
            if (!has(obj, key))
                continue;
            if (/[^\w$]/.test(key)) {
                parts.push(internalInspect(key) + ': ' + internalInspect(obj[key]));
            }
            else {
                parts.push(key + ': ' + internalInspect(obj[key]));
            }
        }
        if (parts.length === 0)
            return '[' + String(obj) + ']';
        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
    }
    if (typeof obj === 'object' && typeof obj.inspect === 'function')
        return obj.inspect();
    if (isMap(obj)) {
        var parts_1 = [];
        mapForEach.call(obj, function (value, key) {
            parts_1.push(internalInspect(key, obj) + ' => ' + internalInspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), parts_1);
    }
    if (isSet(obj)) {
        var parts_2 = [];
        setForEach.call(obj, function (value) {
            parts_2.push(internalInspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), parts_2);
    }
    if (isNumber(obj))
        return markBoxed(Number(obj));
    if (isBoolean(obj))
        return markBoxed(booleanValueOf.call(obj));
    if (isString(obj))
        return markBoxed(internalInspect(String(obj)));
    if (!isDate(obj) && !isRegExp(obj)) {
        var xs = [];
        var keys = objectKeys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (/[^\w$]/.test(key)) {
                xs.push(internalInspect(key) + ': ' + internalInspect(obj[key], obj));
            }
            else
                xs.push(key + ': ' + internalInspect(obj[key], obj));
        }
        if (xs.length === 0)
            return '{}';
        return '{ ' + xs.join(', ') + ' }';
    }
    return String(obj);
}
;
function objectKeys(obj) {
    var keys = [];
    for (var key in obj) {
        if (has(obj, key))
            keys.push(key);
    }
    return keys;
}
function quote(s) {
    return String(s).replace(/"/g, '&quot;');
}
function isArray(obj) { return toStr(obj) === '[object Array]'; }
function isDate(obj) { return toStr(obj) === '[object Date]'; }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]'; }
function isError(obj) { return toStr(obj) === '[object Error]'; }
function isSymbol(obj) { return toStr(obj) === '[object Symbol]'; }
function isString(obj) { return toStr(obj) === '[object String]'; }
function isNumber(obj) { return toStr(obj) === '[object Number]'; }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]'; }
var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}
function toStr(obj) {
    return objectToString.call(obj);
}
function indexOf(xs, x) {
    if (xs.indexOf)
        return xs.indexOf(x);
    for (var i = 0, l = xs.length; i < l; i++)
        if (xs[i] === x)
            return i;
    return -1;
}
function isMap(x) {
    if (!mapSize)
        return false;
    try {
        mapSize.call(x);
        return true;
    }
    catch (e) { }
    return false;
}
function isSet(x) {
    if (!setSize)
        return false;
    try {
        setSize.call(x);
        return true;
    }
    catch (e) { }
    return false;
}
function isElement(x) {
    if (!x || typeof x !== 'object')
        return false;
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement)
        return true;
    return typeof x.nodeName === 'string'
        && typeof x.getAttribute === 'function';
}
function inspectString(str) {
    return "'" + str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte) + "'";
}
function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];
    if (x)
        return '\\' + x;
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
}
function markBoxed(str) {
    return 'Object(' + str + ')';
}
function collectionOf(type, size, entries) {
    return type + ' (' + size + ') {' + entries.join(', ') + '}';
}
//# sourceMappingURL=object-inspect.js.map